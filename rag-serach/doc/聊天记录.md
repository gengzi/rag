# 技术方案一：聊天记录系统（Chat History System）

## 1. 目标

构建一个**高可靠、可扩展、支持多模态消息、多端同步**的聊天记录存储与访问系统，确保用户在任何设备上都能完整回溯对话历史，并支持高效加载与搜索。

## 2. 核心需求

- ✅ 支持文本、图片、文件、网页引用、代码块、引用消息等多种消息类型；
- ✅ 消息严格按时间/序号排序，保证顺序一致性；
- ✅ 支持分页加载（无限滚动）；
- ✅ 多端（Web / iOS / Android）实时同步；
- ✅ 用户可删除/编辑（软删除）单条消息或整体会话；
- ✅ 数据持久化，服务重启/升级无丢失；
- ✅ 高性能读写（万级 QPS）。

## 3. 数据模型

### 3.1 对话表（conversations）

| 字段         | 类型        | 说明                              |
| ------------ | ----------- | --------------------------------- |
| `id`         | TEXT (PK)   | 全局唯一ID，如 `conv_abc123`      |
| `user_id`    | TEXT        | 所属用户                          |
| `title`      | TEXT        | 自动生成的会话标题（可为空）      |
| `created_at` | TIMESTAMPTZ | 创建时间                          |
| `updated_at` | TIMESTAMPTZ | 最后活跃时间                      |
| `status`     | TEXT        | `active` / `archived` / `deleted` |

### 3.2 消息表（messages）

| 字段              | 类型        | 说明                                                      |
| ----------------- | ----------- | --------------------------------------------------------- |
| `id`              | TEXT (PK)   | 消息ID，如 `msg_xyz789`                                   |
| `conversation_id` | TEXT        | 关联会话                                                  |
| `parent_id`       | TEXT        | 引用消息ID（用于QUOTE）                                   |
| `role`            | TEXT        | `user` / `assistant` / `system`                           |
| `type`            | TEXT        | `TEXT`, `IMAGE`, `FILE`, `WEB_REFERENCE`, `CODE_BLOCK` 等 |
| `content`         | JSONB       | 结构化内容（见下表）                                      |
| `visible`         | BOOLEAN     | 是否展示给用户（工具调用中间态可设为 false）              |
| `created_at`      | TIMESTAMPTZ | 创建时间                                                  |
| `seq_num`         | BIGINT      | 自增序号（用于精确排序和续传定位）                        |

#### content 示例：

```json
// TEXT
{ "text": "你好" }

// IMAGE
{ "url": "https://cdn.example.com/img123.jpg", "alt": "风景图" }

// FILE
{ "name": "report.pdf", "size": 20480, "mimeType": "application/pdf", "fileId": "file_456" }

// WEB_REFERENCE
{ "url": "https://example.com/article", "title": "AI趋势", "snippet": "2025年..." }
```

## 4. 存储架构

- **主存储**：PostgreSQL（强一致性、JSONB 支持、事务）
- **缓存**：Redis（缓存最近 N 条消息，加速首屏加载）
- **文件存储**：OSS/S3（所有媒体文件走独立对象存储）

### 索引策略

```sql
-- 快速加载某会话消息
CREATE INDEX idx_msg_conv_seq ON messages(conversation_id, seq_num);

-- 用户会话列表
CREATE INDEX idx_conv_user_updated ON conversations(user_id, updated_at DESC);
```

## 5. API 设计

### 5.1 获取会话列表

```http
GET /api/conversations?page=1&size=20
→ 返回按 updated_at 倒序排列的会话摘要（含最后一条消息预览）
```

### 5.2 加载消息历史

```http
GET /api/conversations/{convId}/messages?beforeSeq=1000&limit=50
→ 返回 seq_num < 1000 的最近 50 条消息（用于向上滚动加载）
```

### 5.3 删除操作

- 单条消息：`PATCH /messages/{msgId}` → `{"visible": false}`
- 整体会话：`DELETE /conversations/{convId}` → 标记 `status=deleted`

## 6. 多端同步机制

- 所有客户端通过 `conversation_id` 访问同一数据源；
- 消息写入后，通过 WebSocket 或 SSE 推送变更事件（可选）；
- 客户端本地缓存 + 版本号（`seq_num`）避免重复加载。

## 7. 容灾与运维

- PostgreSQL 主从复制 + 自动故障转移；
- Redis 缓存穿透保护（空值缓存）；
- 消息写入失败时，进入重试队列（Kafka/RabbitMQ）；
- 定期归档冷数据（>6个月）到低成本存储。